"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[370],{8661:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"vectorization-by-design","metadata":{"permalink":"/typr.github.io/blog/vectorization-by-design","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2026-01-02-vectorization-by-design.md","source":"@site/blog/2026-01-02-vectorization-by-design.md","title":"Vectorization by design","description":"Introduction","date":"2026-01-02T00:00:00.000Z","tags":[{"inline":false,"label":"TypR","permalink":"/typr.github.io/blog/tags/typr","description":"TypR tag description"},{"inline":false,"label":"Vectorization","permalink":"/typr.github.io/blog/tags/vectorization","description":"Vectorization tag description"},{"inline":false,"label":"Array","permalink":"/typr.github.io/blog/tags/array","description":"Array tag description"}],"readingTime":5.67,"hasTruncateMarker":false,"authors":[{"name":"Hategekimana Fabrice","title":"IT trainer, Programming language designer","url":"https://www.linkedin.com/in/fabrice-hategekimana-495b42155/","page":{"permalink":"/typr.github.io/blog/authors/fabrice"},"socials":{"linkedin":"https://www.linkedin.com/in/Fabrice Hategekimana/","github":"https://github.com/fabricehategekimana","newsletter":"https://wedata.ch/"},"imageURL":"https://media.licdn.com/dms/image/v2/D4E03AQEnrBSt3QIuoA/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1696858162823?e=1768435200&v=beta&t=GyoJBTzMC6Ydmylr7EcvkCPlfOTAQFW8DPBsSiPw3BE","key":"fabrice"}],"frontMatter":{"slug":"vectorization-by-design","title":"Vectorization by design","authors":["fabrice"],"tags":["typr","vectorization","array"]},"unlisted":false,"nextItem":{"title":"TypR\'s new official documentation","permalink":"/typr.github.io/blog/new-official-documentation"}},"content":"## Introduction\\nVectorization is one of the greatest tools for data manipulation I know and I am happy that R got this system out of the box. It makes computation simple and simplifies translation from formula to code.\\n\\nUnfortunately I have encountered one limitation: R\'s vectors are not very compatible with functional programming or object-oriented programming, two paradigms I like when building libraries or applications. \\n\\nThroughout this post, we will attempt to construct a concept of a 2D geometric point. A point is a mathematical object that has x and y coordinates. We will use the S3 system for illustration.\\n\\n## Vectorization with R\\n\\nAs I said, R makes it pretty easy to vectorize primitive types like integers or characters. \\n\\n```r\\n# building a vector\\nv <- c(1, 2, 3, 4)\\n\\n# Now we can multiply with a number or add a number\\n\\n3*v + 4\\n#[1]  7 10 13 16\\n```\\n\\nBut what happens if we define a Point type?\\n\\n```r\\n# Point type creation\\nPoint <- function(x, y) {\\n  structure(\\n    list(x = x, y = y),\\n    class = \\"Point\\"\\n  )\\n}\\n```\\n\\nWe will also define a print method to make them easier to visualize.\\n\\n```r\\nprint.Point <- function(p, ...) {\\n  cat(\\"Point<\\", p$x, \\",\\", p$y, \\">\\\\n\\", sep=\\"\\")\\n  invisible(p)\\n}\\n```\\n\\nSo we have our Point type!\\n\\n```\\nPoint(3, 4)\\n#Point<3,4>\\n```\\n\\nAnd we will define a `scale` method to scale a point with a number.\\n\\n```r\\nscale.Point <- function(p, n) {\\n\\tPoint(p$x*n, p$y*n)\\n}\\n```\\n\\nIt\'s now functional!\\n\\n```r\\n# we can use it this way\\nscale(Point(3, 4), 2)\\n#Point<6,8>\\n\\n# or this way\\nPoint(3, 4) |> scale(2)\\n#Point<6,8>\\n```\\n\\nA little bonus: you can also supercharge the `*` operator for the Point class so you can scale using multiplication with a number.\\n\\n```r\\n`*.Point` <- function(p, n) {\\n\\tscale(p, n)\\n}\\n\\n# Now this works\\nPoint(3, 4) * 2\\n#Point<6,8>\\n\\n# But the other way around doesn\'t work\\n2 * Point(3, 4)\\n#Point<6,8>\\n```\\n\\nBut what if we want a vector of types?\\n\\n```r\\npoints <- c(Point(1, 2), \\n\\t\\t\\tPoint(3, 4), \\n\\t\\t\\tPoint(5, 6))\\n\\npoints\\n\\n#$x\\n#[1] 1\\n#\\n#$y\\n#[1] 2\\n#\\n#$x\\n#[1] 3\\n#\\n#$y\\n#[1] 4\\n#\\n#$x\\n#[1] 5\\n#\\n#$y\\n#[1] 6\\n```\\n\\nThe vector of points loses its structure!\\n\\nWe can no longer access it easily:\\n\\n```\\npoints$x\\n#[1] 1\\n\\npoints$y\\n#[1] 2\\n\\npoints[1]\\n#$x\\n#[1] 1\\n```\\n\\nYou have to store them in a list. \\n\\n```r\\n\\npoints <- list(Point(1, 2), \\n\\t\\t\\tPoint(3, 4), \\n\\t\\t\\tPoint(5, 6))\\n\\n\\npoints\\n#[[1]]\\n#Point<1,2>\\n#\\n#[[2]]\\n#Point<3,4>\\n#\\n#[[3]]\\n#Point<5,6>\\n```\\n\\nBut we aren\'t keeping the capability of using native vectorial operations.\\n\\n```r\\n# works well\\npoints[[1]]\\n#Point<1,2>\\n\\npoints$x\\n#NULL\\n\\npoints$y\\n#NULL\\n\\nscale(points, 2)\\n#Error\\n```\\n\\nIt\'s better to directly use vectors inside an S3 object but you have to do some gymnastics. \\n\\nBecause of that, developers should keep in mind they should manually apply vectorization while building functions for objects or functions (which is a mental load by itself).\\n\\n## What about TypR?\\n\\nI\'m glad you asked!\\n\\nTypR uses its own vectorization system named `lifting-based vectorization`. This concept exploits the type system of TypR to infer when to apply vectorization.\\n\\n> The best way to use vectorization is not to think about vectorization.\\n\\nThe developer just has to write their functions for scalar values and TypR will decide when to lift the parameters and the function into a vectorial computation. It\'s also compatible with more complex types like named lists or functions. \\n\\nLet\'s build our `Point` type with a constructor:\\n\\n```julia\\n# Type definition\\ntype Point <- {\\n\\tx: int,\\n\\ty: int\\n};\\n\\n# Constructor\\nlet new_point <- fn(x: int, y: int): Point {\\n\\tlist(x = x, y = y)\\n};\\n```\\n\\nWe will also define a `print` function for points:\\n\\n```julia\\n# print function\\nlet print <- fn(p: Point): Empty {\\n  cat(\\"Point<\\", p$x, \\",\\", p$y, \\">\\", sep=\\"\\");\\n  invisible(p);\\n};\\n```\\n\\nNow we can build a point like before:\\n\\n```julia\\nnew_point(3, 4)\\n# Point<3,4>\\n```\\n\\nWe won\'t forget to implement the `scale` function.\\n\\n```julia\\nlet scale <- fn(p: Point, n: int): Point {\\n\\tnew_point(p$x * n, p$y * n)\\n};\\n\\nnew_point(3, 4) \\n\\t|> scale(2)\\n# Point<6,8>\\n```\\n\\nOf course, we also have the capability of implementing the `*` operator:\\n\\n```julia\\nlet `*` <- fn(p: Point, n: int): Point {\\n\\tscale(p, n)\\n};\\n\\nnew_point(3, 4) * 2\\n# Point<6,8>\\n```\\n\\nNow what about vectors? TypR has its own way to deal with them. Let\'s make a vector of points:\\n\\n```julia\\npoints <- [new_point(1, 2), \\n\\t\\t\\tnew_point(3, 4), \\n\\t\\t\\tnew_point(5, 6)]\\n\\npoints\\n#typed_vec [3]\\n#[1] Point<1,2>\\n#[2] Point<3,4>\\n#[3] Point<5,6>\\n```\\n\\nWe have an array notation like other programming languages. This kind of array automatically exploits the print function for its members.\\n\\nWhat\'s the best part? TypR\'s arrays are vectorizable by default! So these operations work:\\n\\n```julia\\nscale(points, 2)\\n#typed_vec [3]\\n#[1] Point<2,4>\\n#[2] Point<6,8>\\n#[3] Point<10,12>\\n\\npoints \\n\\t|> scale([1, 2, 3])\\n#typed_vec [3]\\n#[1] Point<1,2>\\n#[2] Point<6,8>\\n#[3] Point<15,18>\\n\\npoints * 3\\n#typed_vec [3]\\n#[1] Point<3,6>\\n#[2] Point<9,12>\\n#[3] Point<15,18>\\n```\\n\\nWe also have the possibility to work with types by themselves. Let\'s define the `+` operator:\\n\\n```julia\\nlet `+` <- fn(p1: Point, p2: Point): Point {\\n\\tnew_point(p1$x + p2$x, p1$y + p2$y)\\n};\\n\\n# addition with a scalar\\npoints + new_point(1, 1)\\n#typed_vec [3]\\n#[1] Point<2,3>\\n#[2] Point<4,5>\\n#[3] Point<6,7>\\n\\n# addition with a vector of similar type\\npoints + points\\n#typed_vec [3]\\n#[1] Point<2,4>\\n#[2] Point<6,8>\\n#[3] Point<10,12>\\n```\\n\\nWhat about reduction? One can use the `reduce` function to reduce the elements of the array.\\n\\n```julia\\nreduce(points, `+`<Point>)\\n#Point<9,12>\\n```\\n\\nWe specify the type \\\\<Point\\\\> for the `+` because TypR\'s type system isn\'t doing this kind of inference yet. But as you can see, it summed all elements of points. One can also use a shortcut and use the `sum` function:\\n\\n```julia\\npoints\\n\\t|> sum()\\n#Point<9,12>\\n```\\n\\nIt automatically uses the `+` operator underneath. If your type implements it, `sum` will work on the vector.\\n\\nAnd for functions? We can also do function composition powered by vectors. I won\'t present examples there but later in another publication.\\n\\n## Future works\\n\\nI would like to create vectorized field accessors to make it easier to work with a vector of named lists:\\n\\n```julia\\n# will give all the values contained in the x field of each point\\npoints$x\\n# will give all the values contained in the y field of each point\\npoints$y\\n```\\n\\nIt would also be cool to be able to call similar functions with the same parameters. \\n```julia\\n\\n# vector of functions\\nlet functions <- [`+`, `*`];\\n\\nfunctions(3, 4)\\n# could return:\\n#typed_vec [3]\\n#[1] 7\\n#[2] 12\\n```\\n\\nIt could help with applying a set of statistical models to a specific set of data.\\n\\n## Conclusion\\n\\nEven though lifting-based vectorization looks like reinventing the wheel, I truly believe it\'s a true conceptual heir of the classic vectorization and a logical continuation of it if R was a typed language."},{"id":"new-official-documentation","metadata":{"permalink":"/typr.github.io/blog/new-official-documentation","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-12-30-new-official-documentation.mdx","source":"@site/blog/2025-12-30-new-official-documentation.mdx","title":"TypR\'s new official documentation","description":"After some adventures, the official documentation will soon be open.","date":"2025-12-30T00:00:00.000Z","tags":[{"inline":false,"label":"TypR","permalink":"/typr.github.io/blog/tags/typr","description":"TypR tag description"}],"readingTime":0.17,"hasTruncateMarker":false,"authors":[{"name":"Hategekimana Fabrice","title":"IT trainer, Programming language designer","url":"https://www.linkedin.com/in/fabrice-hategekimana-495b42155/","page":{"permalink":"/typr.github.io/blog/authors/fabrice"},"socials":{"linkedin":"https://www.linkedin.com/in/Fabrice Hategekimana/","github":"https://github.com/fabricehategekimana","newsletter":"https://wedata.ch/"},"imageURL":"https://media.licdn.com/dms/image/v2/D4E03AQEnrBSt3QIuoA/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1696858162823?e=1768435200&v=beta&t=GyoJBTzMC6Ydmylr7EcvkCPlfOTAQFW8DPBsSiPw3BE","key":"fabrice"}],"frontMatter":{"slug":"new-official-documentation","title":"TypR\'s new official documentation","authors":["fabrice"],"tags":["typr"]},"unlisted":false,"prevItem":{"title":"Vectorization by design","permalink":"/typr.github.io/blog/vectorization-by-design"}},"content":"After some adventures, the official documentation will soon be open.\\n\\nDocumentation is sometimes hard to maintain because it is an independent entity to the code base. It\'s even created in a separate github repository."}]}}')}}]);