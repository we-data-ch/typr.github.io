"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[495],{120:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var i=t(1598),o=t(4848),s=t(8453);const a={slug:"vectorization-by-design",title:"Vectorization by design",authors:["fabrice"],tags:["typr","vectorization","array"]},r="Vetorization by design",l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Vectorization with R",id:"vectorization-with-r",level:2},{value:"What about TypR?",id:"what-about-typr",level:2},{value:"Future works",id:"future-works",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"Vectorization is one of the greatest tools for data manipulation I know and I am happy that R got this system out of the box. It makes computation simple and simplifies translation from formula to code."}),"\n",(0,o.jsx)(e.p,{children:"Unfortunately I have encountered one limitation: R's vectors are not very compatible with functional programming or object-oriented programming, two paradigms I like when building libraries or applications."}),"\n",(0,o.jsx)(e.p,{children:"Throughout this post, we will attempt to construct a concept of a 2D geometric point. A point is a mathematical object that has x and y coordinates. We will use the S3 system for illustration."}),"\n",(0,o.jsx)(e.h2,{id:"vectorization-with-r",children:"Vectorization with R"}),"\n",(0,o.jsx)(e.p,{children:"As I said, R makes it pretty easy to vectorize primitive types like integers or characters."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"# building a vector\nv <- c(1, 2, 3, 4)\n\n# Now we can multiply with a number or add a number\n\n3*v + 4\n#[1]  7 10 13 16\n"})}),"\n",(0,o.jsx)(e.p,{children:"But what happens if we define a Point type?"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:'# Point type creation\nPoint <- function(x, y) {\n  structure(\n    list(x = x, y = y),\n    class = "Point"\n  )\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:"We will also define a print method to make them easier to visualize."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:'print.Point <- function(p, ...) {\n  cat("Point<", p$x, ",", p$y, ">\\n", sep="")\n  invisible(p)\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:"So we have our Point type!"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Point(3, 4)\n#Point<3,4>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["And we will define a ",(0,o.jsx)(e.code,{children:"scale"})," method to scale a point with a number."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"scale.Point <- function(p, n) {\n\tPoint(p$x*n, p$y*n)\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"It's now functional!"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"# we can use it this way\nscale(Point(3, 4), 2)\n#Point<6,8>\n\n# or this way\nPoint(3, 4) |> scale(2)\n#Point<6,8>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["A little bonus: you can also supercharge the ",(0,o.jsx)(e.code,{children:"*"})," operator for the Point class so you can scale using multiplication with a number."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"`*.Point` <- function(p, n) {\n\tscale(p, n)\n}\n\n# Now this works\nPoint(3, 4) * 2\n#Point<6,8>\n\n# But the other way around doesn't work\n2 * Point(3, 4)\n#Point<6,8>\n"})}),"\n",(0,o.jsx)(e.p,{children:"But what if we want a vector of types?"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"points <- c(Point(1, 2), \n\t\t\tPoint(3, 4), \n\t\t\tPoint(5, 6))\n\npoints\n\n#$x\n#[1] 1\n#\n#$y\n#[1] 2\n#\n#$x\n#[1] 3\n#\n#$y\n#[1] 4\n#\n#$x\n#[1] 5\n#\n#$y\n#[1] 6\n"})}),"\n",(0,o.jsx)(e.p,{children:"The vector of points loses its structure!"}),"\n",(0,o.jsx)(e.p,{children:"We can no longer access it easily:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"points$x\n#[1] 1\n\npoints$y\n#[1] 2\n\npoints[1]\n#$x\n#[1] 1\n"})}),"\n",(0,o.jsx)(e.p,{children:"You have to store them in a list."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"\npoints <- list(Point(1, 2), \n\t\t\tPoint(3, 4), \n\t\t\tPoint(5, 6))\n\n\npoints\n#[[1]]\n#Point<1,2>\n#\n#[[2]]\n#Point<3,4>\n#\n#[[3]]\n#Point<5,6>\n"})}),"\n",(0,o.jsx)(e.p,{children:"But we aren't keeping the capability of using native vectorial operations."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-r",children:"# works well\npoints[[1]]\n#Point<1,2>\n\npoints$x\n#NULL\n\npoints$y\n#NULL\n\nscale(points, 2)\n#Error\n"})}),"\n",(0,o.jsx)(e.p,{children:"It's better to directly use vectors inside an S3 object but you have to do some gymnastics."}),"\n",(0,o.jsx)(e.p,{children:"Because of that, developers should keep in mind they should manually apply vectorization while building functions for objects or functions (which is a mental load by itself)."}),"\n",(0,o.jsx)(e.h2,{id:"what-about-typr",children:"What about TypR?"}),"\n",(0,o.jsx)(e.p,{children:"I'm glad you asked!"}),"\n",(0,o.jsxs)(e.p,{children:["TypR uses its own vectorization system named ",(0,o.jsx)(e.code,{children:"lifting-based vectorization"}),". This concept exploits the type system of TypR to infer when to apply vectorization."]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"The best way to use vectorization is not to think about vectorization."}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"The developer just has to write their functions for scalar values and TypR will decide when to lift the parameters and the function into a vectorial computation. It's also compatible with more complex types like named lists or functions."}),"\n",(0,o.jsxs)(e.p,{children:["Let's build our ",(0,o.jsx)(e.code,{children:"Point"})," type with a constructor:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"# Type definition\ntype Point <- {\n\tx: int,\n\ty: int\n};\n\n# Constructor\nlet new_point <- fn(x: int, y: int): Point {\n\tlist(x = x, y = y)\n};\n"})}),"\n",(0,o.jsxs)(e.p,{children:["We will also define a ",(0,o.jsx)(e.code,{children:"print"})," function for points:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:'# print function\nlet print <- fn(p: Point): Empty {\n  cat("Point<", p$x, ",", p$y, ">", sep="");\n  invisible(p);\n};\n'})}),"\n",(0,o.jsx)(e.p,{children:"Now we can build a point like before:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"new_point(3, 4)\n# Point<3,4>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["We won't forget to implement the ",(0,o.jsx)(e.code,{children:"scale"})," function."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"let scale <- fn(p: Point, n: int): Point {\n\tnew_point(p$x * n, p$y * n)\n};\n\nnew_point(3, 4) \n\t|> scale(2)\n# Point<6,8>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["Of course, we also have the capability of implementing the ",(0,o.jsx)(e.code,{children:"*"})," operator:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"let `*` <- fn(p: Point, n: int): Point {\n\tscale(p, n)\n};\n\nnew_point(3, 4) * 2\n# Point<6,8>\n"})}),"\n",(0,o.jsx)(e.p,{children:"Now what about vectors? TypR has its own way to deal with them. Let's make a vector of points:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"points <- [new_point(1, 2), \n\t\t\tnew_point(3, 4), \n\t\t\tnew_point(5, 6)]\n\npoints\n#typed_vec [3]\n#[1] Point<1,2>\n#[2] Point<3,4>\n#[3] Point<5,6>\n"})}),"\n",(0,o.jsx)(e.p,{children:"We have an array notation like other programming languages. This kind of array automatically exploits the print function for its members."}),"\n",(0,o.jsx)(e.p,{children:"What's the best part? TypR's arrays are vectorizable by default! So these operations work:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"scale(points, 2)\n#typed_vec [3]\n#[1] Point<2,4>\n#[2] Point<6,8>\n#[3] Point<10,12>\n\npoints \n\t|> scale([1, 2, 3])\n#typed_vec [3]\n#[1] Point<1,2>\n#[2] Point<6,8>\n#[3] Point<15,18>\n\npoints * 3\n#typed_vec [3]\n#[1] Point<3,6>\n#[2] Point<9,12>\n#[3] Point<15,18>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["We also have the possibility to work with types by themselves. Let's define the ",(0,o.jsx)(e.code,{children:"+"})," operator:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"let `+` <- fn(p1: Point, p2: Point): Point {\n\tnew_point(p1$x + p2$x, p1$y + p2$y)\n};\n\n# addition with a scalar\npoints + new_point(1, 1)\n#typed_vec [3]\n#[1] Point<2,3>\n#[2] Point<4,5>\n#[3] Point<6,7>\n\n# addition with a vector of similar type\npoints + points\n#typed_vec [3]\n#[1] Point<2,4>\n#[2] Point<6,8>\n#[3] Point<10,12>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["What about reduction? One can use the ",(0,o.jsx)(e.code,{children:"reduce"})," function to reduce the elements of the array."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"reduce(points, `+`<Point>)\n#Point<9,12>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["We specify the type <Point> for the ",(0,o.jsx)(e.code,{children:"+"})," because TypR's type system isn't doing this kind of inference yet. But as you can see, it summed all elements of points. One can also use a shortcut and use the ",(0,o.jsx)(e.code,{children:"sum"})," function:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"points\n\t|> sum()\n#Point<9,12>\n"})}),"\n",(0,o.jsxs)(e.p,{children:["It automatically uses the ",(0,o.jsx)(e.code,{children:"+"})," operator underneath. If your type implements it, ",(0,o.jsx)(e.code,{children:"sum"})," will work on the vector."]}),"\n",(0,o.jsx)(e.p,{children:"And for functions? We can also do function composition powered by vectors. I won't present examples there but later in another publication."}),"\n",(0,o.jsx)(e.h2,{id:"future-works",children:"Future works"}),"\n",(0,o.jsx)(e.p,{children:"I would like to create vectorized field accessors to make it easier to work with a vector of named lists:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"# will give all the values contained in the x field of each point\npoints$x\n# will give all the values contained in the y field of each point\npoints$y\n"})}),"\n",(0,o.jsx)(e.p,{children:"It would also be cool to be able to call similar functions with the same parameters."}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-julia",children:"\n# vector of functions\nlet functions <- [`+`, `*`];\n\nfunctions(3, 4)\n# could return:\n#typed_vec [3]\n#[1] 7\n#[2] 12\n"})}),"\n",(0,o.jsx)(e.p,{children:"It could help with applying a set of statistical models to a specific set of data."}),"\n",(0,o.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(e.p,{children:"Even though lifting-based vectorization looks like reinventing the wheel, I truly believe it's a true conceptual heir of the classic vectorization and a logical continuation of it if R was a typed language."})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},1598:n=>{n.exports=JSON.parse('{"permalink":"/typr.github.io/blog/vectorization-by-design","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2026-01-02-vectorization-by-design.md","source":"@site/blog/2026-01-02-vectorization-by-design.md","title":"Vectorization by design","description":"Introduction","date":"2026-01-02T00:00:00.000Z","tags":[{"inline":false,"label":"TypR","permalink":"/typr.github.io/blog/tags/typr","description":"TypR tag description"},{"inline":false,"label":"Vectorization","permalink":"/typr.github.io/blog/tags/vectorization","description":"Vectorization tag description"},{"inline":false,"label":"Array","permalink":"/typr.github.io/blog/tags/array","description":"Array tag description"}],"readingTime":5.67,"hasTruncateMarker":false,"authors":[{"name":"Hategekimana Fabrice","title":"IT trainer, Programming language designer","url":"https://www.linkedin.com/in/fabrice-hategekimana-495b42155/","page":{"permalink":"/typr.github.io/blog/authors/fabrice"},"socials":{"linkedin":"https://www.linkedin.com/in/Fabrice Hategekimana/","github":"https://github.com/fabricehategekimana","newsletter":"https://wedata.ch/"},"imageURL":"https://media.licdn.com/dms/image/v2/D4E03AQEnrBSt3QIuoA/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1696858162823?e=1768435200&v=beta&t=GyoJBTzMC6Ydmylr7EcvkCPlfOTAQFW8DPBsSiPw3BE","key":"fabrice"}],"frontMatter":{"slug":"vectorization-by-design","title":"Vectorization by design","authors":["fabrice"],"tags":["typr","vectorization","array"]},"unlisted":false,"nextItem":{"title":"TypR\'s new official documentation","permalink":"/typr.github.io/blog/new-official-documentation"}}')},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);