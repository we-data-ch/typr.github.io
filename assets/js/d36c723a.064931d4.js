"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[370],{8661:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"vectorization-by-design","metadata":{"permalink":"/typr.github.io/blog/vectorization-by-design","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2026-01-02-vectorization-by-design.md","source":"@site/blog/2026-01-02-vectorization-by-design.md","title":"Vectorization by design","description":"Introduction","date":"2026-01-02T00:00:00.000Z","tags":[{"inline":false,"label":"TypR","permalink":"/typr.github.io/blog/tags/typr","description":"TypR tag description"},{"inline":false,"label":"Vectorization","permalink":"/typr.github.io/blog/tags/vectorization","description":"Vectorization tag description"},{"inline":false,"label":"Array","permalink":"/typr.github.io/blog/tags/array","description":"Array tag description"}],"readingTime":6.98,"hasTruncateMarker":false,"authors":[{"name":"Hategekimana Fabrice","title":"IT trainer, Programming language designer","url":"https://www.linkedin.com/in/fabrice-hategekimana-495b42155/","page":{"permalink":"/typr.github.io/blog/authors/fabrice"},"socials":{"linkedin":"https://www.linkedin.com/in/Fabrice Hategekimana/","github":"https://github.com/fabricehategekimana","newsletter":"https://wedata.ch/"},"imageURL":"https://media.licdn.com/dms/image/v2/D4E03AQEnrBSt3QIuoA/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1696858162823?e=1768435200&v=beta&t=GyoJBTzMC6Ydmylr7EcvkCPlfOTAQFW8DPBsSiPw3BE","key":"fabrice"}],"frontMatter":{"slug":"vectorization-by-design","title":"Vectorization by design","authors":["fabrice"],"tags":["typr","vectorization","array"]},"unlisted":false,"nextItem":{"title":"TypR\'s new official documentation","permalink":"/typr.github.io/blog/new-official-documentation"}},"content":"## Introduction\\nVectorization is one of the greatest tools for data manipulation I know and I am happy that R got this system out of the box. It makes computation simple and simplifies translation from formula to code.\\n\\nUnfortunately I have encountered one limitation: R\'s vectors are not very compatible with functional programming or object-oriented programming, two paradigms I like when building libraries or applications. This is what TypR\'s vectorization is improving with the mechanism of `lifting-based vectorization`.\\n\\nThroughout this post, we will attempt to construct a concept of a 2D geometric point. A point is a mathematical object that has x and y coordinates. We will use the S3 system from R for illustration and then use TypR\'s type system.\\n\\n## Vectorization with R\\n\\nAs I said, R makes it pretty easy to vectorize primitive types like integers or characters. \\n\\n```r\\n# building a vector\\nv <- c(1, 2, 3, 4)\\n\\n# Now we can multiply with a number or add a number\\n3*v + 4\\n#[1]  7 10 13 16\\n```\\n\\n### Point construction\\nBut what happens if we define a Point type?\\n\\n```r\\n# Point type creation with S3 (without valdation for simplicity)\\nPoint <- function(x, y) {\\n  structure(\\n    list(x = x, y = y),\\n    class = \\"Point\\"\\n  )\\n}\\n```\\n\\nWe will also define a print method to make a point easier to visualize.\\n\\n```r\\nprint.Point <- function(p, ...) {\\n  cat(\\"Point<\\", p$x, \\",\\", p$y, \\">\\\\n\\", sep=\\"\\")\\n  invisible(p)\\n}\\n```\\n\\nSo we have our Point type!\\n\\n```r\\nPoint(3, 4)\\n#Point<3,4>\\n```\\n\\nAnd we will define a `scale` method to scale a point with a number. It will multiply each coordinate with this number.\\n\\n```r\\nscale.Point <- function(p, n) {\\n\\tPoint(p$x*n, p$y*n)\\n}\\n```\\n\\nIt\'s now functional!\\n\\n```r\\n# we can use it this way\\nscale(Point(3, 4), 2)\\n#Point<6,8>\\n\\n# or this way\\nPoint(3, 4) |> scale(2)\\n#Point<6,8>\\n```\\n\\nA little bonus: we will also supercharge the `*` operator for the Point class so scaling can be done using right multiplication with a number.\\n\\n```r\\n# Definition of the multiplication operator for Point \\n`*.Point` <- function(p, n) {\\n\\tscale(p, n)\\n}\\n\\n# Now this works\\nPoint(3, 4) * 2\\n#Point<6,8>\\n\\n# But the other way around doesn\'t work\\n2 * Point(3, 4)\\n#Error\\n```\\n\\n### Point vectorization\\nBut what if we want a vector of Point?\\n\\n```r\\npoints <- c(Point(1, 2), \\n\\t\\t\\tPoint(3, 4), \\n\\t\\t\\tPoint(5, 6))\\n\\npoints\\n\\n#$x\\n#[1] 1\\n#\\n#$y\\n#[1] 2\\n#\\n#$x\\n#[1] 3\\n#\\n#$y\\n#[1] 4\\n#\\n#$x\\n#[1] 5\\n#\\n#$y\\n#[1] 6\\n```\\n\\nThe vector of points loses its structure! We can\'t access it as expected:\\n\\n```\\npoints$x\\n#[1] 1\\n\\npoints$y\\n#[1] 2\\n\\npoints[1]\\n#$x\\n#[1] 1\\n```\\n\\nTo make a vector of points, we have to store them in a list. In R, a list is a vector of pointers so one can save any structure with them.\\n\\n```r\\n\\npoints <- list(Point(1, 2), \\n\\t\\t\\tPoint(3, 4), \\n\\t\\t\\tPoint(5, 6))\\n\\n\\npoints\\n#[[1]]\\n#Point<1,2>\\n#\\n#[[2]]\\n#Point<3,4>\\n#\\n#[[3]]\\n#Point<5,6>\\n```\\n\\nBut we aren\'t keeping the capability of using native vectorial operations anymore.\\n\\n```r\\n# works well\\npoints[[1]]\\n#Point<1,2>\\n\\nscale(points, 2)\\n#Error\\n\\npoints$x\\n#NULL\\n\\npoints$y\\n#NULL\\n```\\n\\nIt\'s better to directly use vectors inside an S3 object but you have to do some gymnastics for that.\\nBecause of that, developers should keep in mind they should manually apply vectorization while building functions for objects or functions (which is a mental load by itself).\\n\\n## What about TypR?\\n\\nI\'m glad you asked!\\n\\nTypR uses its own vectorization system named `lifting-based vectorization`. This concept exploits the type system of TypR to infer when to apply vectorization.\\n\\n> The best way to use vectorization is not to think about vectorization.\\n\\nThe developer just has to write their functions for scalar values and TypR will decide when to lift the parameters and the function into a vectorial computation based on how the function is used. It\'s also compatible with more complex types like named lists or functions. \\n\\n### Point construction\\nLet\'s build our `Point` type and a constructor with TypR:\\n\\n```julia\\n# Type definition\\ntype Point <- {\\n\\tx: int,\\n\\ty: int\\n};\\n\\n# Constructor for the Point type\\nlet new_point <- fn(x: int, y: int): Point {\\n\\tlist(x = x, y = y)\\n};\\n```\\n\\nWe will also define a `print` function for points:\\n\\n```julia\\n# print function\\nlet print <- fn(p: Point): Empty {\\n  cat(\\"Point<\\", p$x, \\",\\", p$y, \\">\\", sep=\\"\\");\\n  invisible(p);\\n};\\n```\\n\\nNow we can build a point like before:\\n\\n```julia\\nnew_point(3, 4)\\n#Point<3,4>\\n```\\n\\nWe won\'t forget to implement the `scale` function.\\n\\n```julia\\nlet scale <- fn(p: Point, n: int): Point {\\n\\tnew_point(p$x * n, p$y * n)\\n};\\n\\nnew_point(3, 4) \\n\\t|> scale(2)\\n#Point<6,8>\\n```\\n\\nOf course, we also have the capability of implementing the `*` operator:\\n\\n```julia\\nlet `*` <- fn(p: Point, n: int): Point {\\n\\tscale(p, n)\\n};\\n\\nnew_point(3, 4) * 2\\n#Point<6,8>\\n```\\n\\n### Point vectorization\\nNow what about vectors? TypR has its own way to deal with them. For better understanding, let\'s make a vector of points:\\n\\n```julia\\n# creating a vector of points in TypR\\npoints <- [new_point(1, 2), \\n\\t\\t\\tnew_point(3, 4), \\n\\t\\t\\tnew_point(5, 6)]\\n\\npoints\\n#typed_vec [3]\\n#[1] Point<1,2>\\n#[2] Point<3,4>\\n#[3] Point<5,6>\\n```\\n\\nWe have an array notation syntax like other programming languages. This kind of array automatically exploits the print function for its members.\\n\\nWhat\'s the best part? *TypR\'s arrays are vectorized by default*! So these operations work:\\n\\n```julia\\n# scaling a group of point with one number\\nscale(points, 2)\\n#typed_vec [3]\\n#[1] Point<2,4>\\n#[2] Point<6,8>\\n#[3] Point<10,12>\\n\\n# same but with pipe\\npoints \\n\\t|> scale([1, 2, 3])\\n#typed_vec [3]\\n#[1] Point<1,2>\\n#[2] Point<6,8>\\n#[3] Point<15,18>\\n\\n# same but with the \\"*\\" operator\\npoints * 3\\n#typed_vec [3]\\n#[1] Point<3,6>\\n#[2] Point<9,12>\\n#[3] Point<15,18>\\n```\\n\\nWe also have the possibility to work with types by themselves. Let\'s define the `+` operator that will help adding two points by adding their respective fields.\\n\\n```julia\\n# Definition of the \\"+\\" operator\\nlet `+` <- fn(p1: Point, p2: Point): Point {\\n\\tnew_point(p1$x + p2$x, p1$y + p2$y)\\n};\\n\\n# adding a group of point with a scalar\\npoints + new_point(1, 1)\\n#typed_vec [3]\\n#[1] Point<2,3>\\n#[2] Point<4,5>\\n#[3] Point<6,7>\\n\\n# adding two group of point of the same type\\npoints + points\\n#typed_vec [3]\\n#[1] Point<2,4>\\n#[2] Point<6,8>\\n#[3] Point<10,12>\\n```\\n\\nAnd what about reduction functions? One can use the `reduce` function to reduce the elements of the array.\\n\\n```julia\\n# will add all the points\\nreduce(points, `+`<Point>)\\n#Point<9,12>\\n```\\n\\nWe specify the type \\\\<Point\\\\> for the `+` operator because TypR\'s type system isn\'t doing this kind of inference yet. But as you can see, it summed all elements of points. One can also use a shortcut by using the `sum` function:\\n\\n```julia\\npoints\\n\\t|> sum()\\n#Point<9,12>\\n```\\n\\nIt automatically uses the `+` operator underneath. If your type implements it, `sum` will work on the vector.\\n\\nAnd for functions? We can also do function composition powered by vectors. I won\'t present examples there but later in another publication.\\n\\n## Future works\\n\\n### Type specifique applications\\nI would like to create vectorized field accessors to make it easier to work with a vector of named lists:\\n\\n```julia\\n# will give all the values contained in the x field of each point\\npoints$x\\n# will give all the values contained in the y field of each point\\npoints$y\\n```\\n\\nIt would also be cool to be able to call similar functions with the same parameters. \\n```julia\\n# vector of functions\\nlet functions <- [`+`, `*`];\\n\\nfunctions(3, 4)\\n# could return:\\n#typed_vec [3]\\n#[1] 7\\n#[2] 12\\n```\\n\\nIt could help with applying a set of statistical models to a specific set of data.\\n\\n### Compabilities with other system\\n\\nUnderneath, TypR\'s array are using a custom S3 object for data storage and vectorization. This doesn\'t invalidate native vectors or data.frame from R who will be faster and efficient. I want to create bridge that will help convert them into native types.\\n\\n```julia\\n# In the future, Array -> Vector for performances\\nlet arr <- [1, 2, 3, 4];\\nlet vec <- arr |> to_vec();\\n\\n# In the future, Array -> dataframe for performances\\nlet df <- points |> to_df();\\n```\\n\\n## Conclusion\\n\\nEven though lifting-based vectorization looks like reinventing the wheel, I truly believe it\'s a true conceptual heir of the classic way of doing vectorization and a logical continuation of it if R was a typed language.\\n\\nNow the responsibility of vectorizing functions is no more in the hands of the developper who can now focus on solving the problem. TypR offer a flexible interface to works with vectors."},{"id":"new-official-documentation","metadata":{"permalink":"/typr.github.io/blog/new-official-documentation","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-12-30-new-official-documentation.mdx","source":"@site/blog/2025-12-30-new-official-documentation.mdx","title":"TypR\'s new official documentation","description":"After some adventures, the official documentation will soon be open.","date":"2025-12-30T00:00:00.000Z","tags":[{"inline":false,"label":"TypR","permalink":"/typr.github.io/blog/tags/typr","description":"TypR tag description"}],"readingTime":0.17,"hasTruncateMarker":false,"authors":[{"name":"Hategekimana Fabrice","title":"IT trainer, Programming language designer","url":"https://www.linkedin.com/in/fabrice-hategekimana-495b42155/","page":{"permalink":"/typr.github.io/blog/authors/fabrice"},"socials":{"linkedin":"https://www.linkedin.com/in/Fabrice Hategekimana/","github":"https://github.com/fabricehategekimana","newsletter":"https://wedata.ch/"},"imageURL":"https://media.licdn.com/dms/image/v2/D4E03AQEnrBSt3QIuoA/profile-displayphoto-shrink_800_800/profile-displayphoto-shrink_800_800/0/1696858162823?e=1768435200&v=beta&t=GyoJBTzMC6Ydmylr7EcvkCPlfOTAQFW8DPBsSiPw3BE","key":"fabrice"}],"frontMatter":{"slug":"new-official-documentation","title":"TypR\'s new official documentation","authors":["fabrice"],"tags":["typr"]},"unlisted":false,"prevItem":{"title":"Vectorization by design","permalink":"/typr.github.io/blog/vectorization-by-design"}},"content":"After some adventures, the official documentation will soon be open.\\n\\nDocumentation is sometimes hard to maintain because it is an independent entity to the code base. It\'s even created in a separate github repository."}]}}')}}]);