"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[182],{3631:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"philosophy/intro","title":"Philosophy","description":"What is TypR ?","source":"@site/docs/philosophy/intro.md","sourceDirName":"philosophy","slug":"/philosophy/intro","permalink":"/typr.github.io/docs/philosophy/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/philosophy/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Coming soon...","permalink":"/typr.github.io/docs/intro"},"next":{"title":"Vetorization by design","permalink":"/typr.github.io/docs/philosophy/vectorization_by_design"}}');var o=n(4848),a=n(8453);const s={},r="Philosophy",d={},c=[{value:"What is TypR ?",id:"what-is-typr-",level:2},{value:"Code by design vs code by effort",id:"code-by-design-vs-code-by-effort",level:2},{value:"1. Fluent API by design",id:"1-fluent-api-by-design",level:2},{value:"2. Vectorization by design",id:"2-vectorization-by-design",level:2},{value:"3. Functional inheritance by design",id:"3-functional-inheritance-by-design",level:2},{value:"4. Data driven code by design",id:"4-data-driven-code-by-design",level:2},{value:"5. Algorithmic democracy by design",id:"5-algorithmic-democracy-by-design",level:2}];function l(e){const i={a:"a",blockquote:"blockquote",h1:"h1",h2:"h2",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"philosophy",children:"Philosophy"})}),"\n",(0,o.jsx)(i.h2,{id:"what-is-typr-",children:"What is TypR ?"}),"\n",(0,o.jsx)(i.p,{children:"TypR is not just R with types. TypR is a programming language built for datascience and a powerful software engineering tool that happened to be a typed version of R."}),"\n",(0,o.jsx)(i.h2,{id:"code-by-design-vs-code-by-effort",children:"Code by design vs code by effort"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsx)(i.p,{children:"Create clean data science code by design, not by effort."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Creating correct code and creating clean code are independent things. A correct code is a code that fulfill it's purpose while clean code make the project maintainable and scalable for the long run."}),"\n",(0,o.jsx)(i.p,{children:"R is great at making correct code for research purpose. But it doesn't give the set of tools needed to make clean code easely, letting package developper holding the responsibility of doing clean code by effort."}),"\n",(0,o.jsx)(i.p,{children:'"By effort" also mean there is a mental load taking brain resources that could be used for other things directly related to the goal.'}),"\n",(0,o.jsx)(i.p,{children:"That's why TypR deliver a group of tools to make package and app developpment easier. It also tend to make maintenance and scalability painless. That's why it favor clean code by design."}),"\n",(0,o.jsx)(i.h2,{id:"1-fluent-api-by-design",children:"1. Fluent API by design"}),"\n",(0,o.jsx)(i.p,{children:"Building package for other users can be hard since we need to know how to expose functionalities to them. Fortunately, with TypR, you don't have to worry wich OO System you want (S3, S4, R6, S7) or if you just want to build vanilla code. The main principle is simple:"}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsx)(i.p,{children:"All you need are types and functions."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"By using the power of uniform function call, you have different ways to call your functions (classic, piping, method call). This functionality also support single dispatch and transpile to native S3 code."}),"\n",(0,o.jsx)(i.p,{children:"Coding is now about designing your data types and how you manipulate them."}),"\n",(0,o.jsx)(i.h2,{id:"2-vectorization-by-design",children:"2. Vectorization by design"}),"\n",(0,o.jsxs)(i.p,{children:["See ",(0,o.jsx)(i.a,{href:"/typr.github.io/docs/philosophy/vectorization_by_design",children:"Vectorization by design"})]}),"\n",(0,o.jsx)(i.h2,{id:"3-functional-inheritance-by-design",children:"3. Functional inheritance by design"}),"\n",(0,o.jsx)(i.p,{children:"TypR will give the user the possibility to practic a form of inheritance by subtyping. TypR will figure out a type hierarchy by itself and will create inheritance between types. The user will also be able to inherit functions by delegation."}),"\n",(0,o.jsx)(i.h2,{id:"4-data-driven-code-by-design",children:"4. Data driven code by design"}),"\n",(0,o.jsx)(i.p,{children:"The inference power of TypR's type system brings more clarity, precision and computation for data types. We have the arrity for arrays and row polymorphism for fields that help adapt to everchanging datas."}),"\n",(0,o.jsx)(i.h2,{id:"5-algorithmic-democracy-by-design",children:"5. Algorithmic democracy by design"}),"\n",(0,o.jsx)(i.p,{children:"You have the ability to define more general purpose with interface inference and work on it."})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var t=n(6540);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);